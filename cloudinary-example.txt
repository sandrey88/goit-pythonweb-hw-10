Збереження файлів у хмарі


Cloudinary є провідним провайдером послуг хмарного зберігання й обробки мультимедіа. Він пропонує широкий спектр послуг, включно зі зберіганням, перетворенням, оптимізацією, керуванням і делегуванням зображень, відео та аудіо. Він використовує розширені алгоритми машинного навчання, щоб забезпечити високу якість зображень і мінімізувати час завантаження. Таким чином, Cloudinary може істотно спростити роботу із зображеннями та відео, а також поліпшити продуктивність вашого сайту.



Після реєстрації, для того щоб працювати із сервісом, на Dashboard ми отримаємо ключі доступу у Product Environment Credentials. Помістимо їх у наш файл .env (прим. Замініть їх на свої значення, якщо будете виконувати завантаження файлів).

.env

CLOUDINARY_NAME=cloud_name
CLOUDINARY_API_KEY=12345678
CLOUDINARY_API_SECRET=api_secret


Розширимо наш клас конфігурації Settingns новими змінними src/conf/config.py. 
##### 
(в нашому проєкті це здається якийсь інший файл)
#####

from pydantic import ConfigDict, EmailStr
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DB_URL: str
    JWT_SECRET: str
    JWT_ALGORITHM: str = "HS256"
    JWT_EXPIRATION_SECONDS: int = 3600

    MAIL_USERNAME: EmailStr = "example@meta.ua"
    MAIL_PASSWORD: str = "secretPassword"
    MAIL_FROM: EmailStr = "example@meta.ua"
    MAIL_PORT: int = 465
    MAIL_SERVER: str = "smtp.meta.ua"
    MAIL_FROM_NAME: str = "Rest API Service"
    MAIL_STARTTLS: bool = False
    MAIL_SSL_TLS: bool = True
    USE_CREDENTIALS: bool = True
    VALIDATE_CERTS: bool = True

    CLD_NAME: str
    CLD_API_KEY: int = 326488457974591
    CLD_API_SECRET: str = "secret"

    model_config = ConfigDict(
        extra="ignore", env_file=".env", env_file_encoding="utf-8", case_sensitive=True
    )

settings = Settings()



Зараз наш аватар у користувача — це посилання, згенероване сервісом Gravatar. Ми збираємося дозволити користувачеві завантажувати свої аватари в нашому REST API. Для цього визначимо новий маршрут і помістимо його у файл src/routes/users.py.

...
@router.patch("/avatar", response_model=User)
async def update_avatar_user(
    file: UploadFile = File(),
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    avatar_url = UploadFileService(
        settings.CLD_NAME, settings.CLD_API_KEY, settings.CLD_API_SECRET
    ).upload_file(file, user.username)

    user_service = UserService(db)
    user = await user_service.update_avatar_url(user.email, avatar_url)

    return user



Для того щоб користувач оновив зображення свого аватара, ми використовуємо маршрут /users/avatar та операцію PATCH. Завантажений файл приймається через параметр file, який буде об’єктом UploadFile, з модуля fastapi.UploadFile.



Далі відбувається завантаження файлу у хмару сервісом UploadFileService.

Розглянемо його та розмітимо у файлі src/services/upload_file.py.

import cloudinary
import cloudinary.uploader

class UploadFileService:
    def __init__(self, cloud_name, api_key, api_secret):
        self.cloud_name = cloud_name
        self.api_key = api_key
        self.api_secret = api_secret
        cloudinary.config(
            cloud_name=self.cloud_name,
            api_key=self.api_key,
            api_secret=self.api_secret,
            secure=True,
        )

    @staticmethod
    def upload_file(file, username) -> str:
        public_id = f"RestApp/{username}"
        r = cloudinary.uploader.upload(file.file, public_id=public_id, overwrite=True)
        src_url = cloudinary.CloudinaryImage(public_id).build_url(
            width=250, height=250, crop="fill", version=r.get("version")
        )
        return src_url



Ми використовуємо бібліотеку cloudinary для завантаження зображення у хмару та його подальшого зберігання. Функція cloudinary.config у конструкторі класу UploadFileService застосовується для налаштування з’єднання з обліковим записом cloudinary, використовуючи значення з нашого модуля налаштувань.

Метод завантаження upload_file за допомогою функції cloudinary.uploader.upload використовується для завантаження файлу зображення, при цьому параметр public_id встановлюємо відповідно до імені поточного користувача username та директорії у хмарі з іменем RestApp. Вона створиться автоматично при першому завантаженні.



Після того як зображення завантажено, ми отримуємо URL-адресу зображення за допомогою класу cloudinary.CloudinaryImage та методу build_url. Ми передаємо параметр version у функцію build_url, яка генерує URL зображення із заданими параметрами ширини, висоти та кадру. За допомогою параметра version можна вказати, яку саме версію зображення необхідно відобразити на сторінці. 

Наприклад, якщо на сторінці раніше відображалася одна версія зображення, але користувач вніс зміни до зображення та перезавантажив його на сервер, то за допомогою параметра version можна отримати нову версію зображення з урахуванням змін, які були зроблені користувачем.


Значення параметра crop='fill' означає, що зображення буде масштабовано до заданого розміру, а потім обрізано до того, щоб повністю заповнити область із цим розміром. Цей параметр зазвичай використовується для забезпечення того, що зображення має певний розмір і зберігає пропорції, які потрібні для конкретного дизайну або макета. Отримана URL-адреса src_url повертається в обробник маршруту.



Повертаємося до обробника маршруту update_avatar_user. Отримавши шлях до завантаженого аватара користувача avatar_url, необхідно викликати сервіс користувача та зберегти зміни в базі даних.



Додамо наступний метод у сервіс користувача UserService:

    async def update_avatar_url(self, email: str, url: str):
        return await self.repository.update_avatar_url(email, url)



Далі додамо метод update_avatar_url у репозиторій користувача src/repository/users.py, який оновлює аватар користувача в базі даних:

    async def update_avatar_url(self, email: str, url: str) -> User:
        user = await self.get_user_by_email(email)
        user.avatar = url
        await self.db.commit()
        await self.db.refresh(user)
        return user



Тут оновлена модель користувача повертається як відповідь на виклик API.

Таким чином, досить безпечно і просто ми змогли реалізувати складну операцію зі зберігання аватарів користувачів у хмарному сервісі.